Enorm = function (X)
{
if (is.complex(X)) {
n <- sqrt(Re(c(st(X) %*% X)))
}
else {
n <- sqrt(sum(diag(t(X) %*% X)))
}
n
}
# Enorm
Enorm = function (X){
if (is.complex(X)) {
n <- sqrt(Re(c(st(X) %*% X)))
}
else {
n <- sqrt(sum(diag(t(X) %*% X)))
}
n
}
Enormalize = function (x){
return(x/Enorm(x))
}
# realtocomplex
realtocomplex = function (x){
k <- nrow(x)
zstar <- x[, 1] + (0+1i) * x[, 2]
zstar
}
preshape = function (x){
if (is.complex(x)) {
k <- nrow(as.matrix(x))
h <- defh(k - 1)
zstar <- x
ztem <- h %*% zstar
size <- sqrt(diag(Re(st(ztem) %*% ztem)))
if (is.vector(zstar))
z <- ztem/size
if (is.matrix(zstar))
z <- ztem %*% diag(1/size)
}
else {
if (length(dim(x)) == 3) {
k <- dim(x)[1]
h <- defh(k - 1)
n <- dim(x)[3]
m <- dim(x)[2]
z <- array(0, c(k - 1, m, n))
for (i in 1:n) {
z[, , i] <- h %*% x[, , i]
size <- centroid.size(x[, , i])
z[, , i] <- z[, , i]/size
}
}
else {
k <- nrow(as.matrix(x))
h <- defh(k - 1)
ztem <- h %*% x
size <- centroid.size(x)
z <- ztem/size
}
}
z
}
riemdist <- function (x, y, reflect = FALSE)
{
if (sum((x - y)^2) == 0) {
riem <- 0
}
if (sum((x - y)^2) != 0) {
if (reflect == FALSE) {
if (ncol(as.matrix(x)) < 3) {
if (is.complex(x) == FALSE) {
x <- realtocomplex(x)
}
if (is.complex(y) == FALSE) {
y <- realtocomplex(y)
}
riem <- c(acos(min(1, (Mod(st(preshape(x)) %*%
preshape(y))))))
}
else {
m <- ncol(x)
z <- preshape(x)
w <- preshape(y)
Q <- t(z) %*% w %*% t(w) %*% z
ev <- eigen(t(z) %*% w)$values
check <- 1
for (i in 1:m) {
check <- check * ev[i]
}
ev <- sqrt(abs(eigen(Q, symmetric = TRUE)$values))
if (Re(check) < 0)
ev[m] <- -ev[m]
riem <- acos(min(sum(ev), 1))
}
}
if (reflect == TRUE) {
m <- ncol(x)
z <- preshape(x)
w <- preshape(y)
Q <- t(z) %*% w %*% t(w) %*% z
ev <- sqrt(abs(eigen(Q, symmetric = TRUE)$values))
riem <- acos(min(sum(ev), 1))
}
}
riem
}
shape_distance <- function (x, y, type = "full", reflect = FALSE){
if (type == "full") {
out <- sin(riemdist(x, y, reflect = reflect))
}
if (type == "partial") {
out <- sqrt(2) * sqrt(abs(1 - cos(riemdist(x, y, reflect = reflect))))
}
if (type == "Riemannian") {
out <- riemdist(x, y, reflect = reflect)
}
if (type == "sizeandshape") {
out <- ssriemdist(x, y, reflect = reflect)
}
out
}
bone_shapes = bone_list$x
bone_shapes = cbind(bone_shapes, bone_list$y)
bone_1 = bone_shapes[1:100,]
shape_distance(bone_1)
?riemdist
??riemdist
library(shapes)
riemdist
# Enorm
Enorm = function (X){
if (is.complex(X)) {
n <- sqrt(Re(c(st(X) %*% X)))
}
else {
n <- sqrt(sum(diag(t(X) %*% X)))
}
n
}
Enormalize = function (x){
return(x/Enorm(x))
}
# realtocomplex
realtocomplex = function (x){
k <- nrow(x)
zstar <- x[, 1] + (0+1i) * x[, 2]
zstar
}
preshape = function (x){
if (is.complex(x)) {
k <- nrow(as.matrix(x))
h <- defh(k - 1)
zstar <- x
ztem <- h %*% zstar
size <- sqrt(diag(Re(st(ztem) %*% ztem)))
if (is.vector(zstar))
z <- ztem/size
if (is.matrix(zstar))
z <- ztem %*% diag(1/size)
}
else {
if (length(dim(x)) == 3) {
k <- dim(x)[1]
h <- defh(k - 1)
n <- dim(x)[3]
m <- dim(x)[2]
z <- array(0, c(k - 1, m, n))
for (i in 1:n) {
z[, , i] <- h %*% x[, , i]
size <- centroid.size(x[, , i])
z[, , i] <- z[, , i]/size
}
}
else {
k <- nrow(as.matrix(x))
h <- defh(k - 1)
ztem <- h %*% x
size <- centroid.size(x)
z <- ztem/size
}
}
z
}
riemdist <- function (x, y, reflect = FALSE){
if (sum((x - y)^2) == 0) {
riem <- 0
}
if (sum((x - y)^2) != 0) {
if (reflect == FALSE) {
if (ncol(as.matrix(x)) < 3) {
if (is.complex(x) == FALSE) {
x <- realtocomplex(x)
}
if (is.complex(y) == FALSE) {
y <- realtocomplex(y)
}
riem <- c(acos(min(1, (Mod(st(preshape(x)) %*%
preshape(y))))))
}
else {
m <- ncol(x)
z <- preshape(x)
w <- preshape(y)
Q <- t(z) %*% w %*% t(w) %*% z
ev <- eigen(t(z) %*% w)$values
check <- 1
for (i in 1:m) {
check <- check * ev[i]
}
ev <- sqrt(abs(eigen(Q, symmetric = TRUE)$values))
if (Re(check) < 0)
ev[m] <- -ev[m]
riem <- acos(min(sum(ev), 1))
}
}
if (reflect == TRUE) {
m <- ncol(x)
z <- preshape(x)
w <- preshape(y)
Q <- t(z) %*% w %*% t(w) %*% z
ev <- sqrt(abs(eigen(Q, symmetric = TRUE)$values))
riem <- acos(min(sum(ev), 1))
}
}
riem
}
shape_distance <- function (x, y, type = "full", reflect = FALSE){
if (type == "full") {
out <- sin(riemdist(x, y, reflect = reflect))
}
if (type == "partial") {
out <- sqrt(2) * sqrt(abs(1 - cos(riemdist(x, y, reflect = reflect))))
}
if (type == "Riemannian") {
out <- riemdist(x, y, reflect = reflect)
}
if (type == "sizeandshape") {
out <- ssriemdist(x, y, reflect = reflect)
}
out
}
bone_shapes = bone_list$x
bone_shapes = cbind(bone_shapes, bone_list$y)
bone_1 = bone_shapes[1:100,]
shape_distance(bone_1)
shape_distance(bone_1, type= "full")
bone_2 = bone_shapes[101:200,]
shape_distance(bone_1, bone_2, type= "full")
install.packages("gtools")
library(gtools)
?permutations
testarr = array(1:500, dim = c(10, 10, 5))
testarr
dim(testarr)
ndim(testarr)
nrow(testarr)
ncol(testarr)
dimnames(testarr)
dim(testarr)[3]
nrow(permutations(dim(x)[3], 2))
nrow(permutations(dim(testarr)[3], 2))
nrow(combinations(dim(testarr)[3], 2))
testarr = array(1:71, dim = c(3, 3, 3))
testarr
testarr = array(1:81, dim = c(3, 3, 3))
testarr
testarr = array(1:27, dim = c(3, 3, 3))
testarr
testarr2 = array(1:27, dim = c(3, 3, 3))
outer(testarr, testarr2, FUN = "/")
testarr = array(1:27, dim = c(3, 3))
testarr2 = array(1:27, dim = c(3, 3))
testarr
testarr2
outer(testarr, testarr2, FUN = "*")
outer(testarr[1], FUN = "*")
outer(testarr, FUN = "*")
?outer
testarr = array(1:27, dim = c(100, 2, 3))
testarr
testarr2 = array(1:27, dim = c(25, 2, 3))
nrow(combinations(dim(testarr)[3], 2))
outer(testarr, testarr, FUN = shape_distance)
shape_distance(bone_1, bone_2, type= "full")
outer(testarr, testarr, FUN = shapes::shape_distance)
??calc_shape_distance
?shape_distance
??shape_distance
?procdist
outer(testarr, testarr, FUN = procdist)
?transform
?t
outer(t(testarr), t(testarr), FUN = procdist)
?outer
x <- 1:9; names(x) <- x
x
# Multiplication & Power Tables
x %o% x
y <- 2:8; names(y) <- paste(y,":", sep = "")
y
outer(y, x, "^")
outer(month.abb, 1999:2003, FUN = "paste")
## three way multiplication table:
x %o% x %o% y[1:3]
## three way multiplication table:
x %o% x %o% y[1:3]
y <- 2:8; names(y) <- paste(y,":", sep = "")
y
"im dumb"
'im v tired'
'im sleep'
'*sleepy'
'im sleepy'
3+5
33333+3223342
+5
|5|
|
abs(5)
abs(-5)
abs(i)
abs(PI)
abs(pi)
install.packages("shiny")
?procdist
??procdist
?elastic.distance
??elastic.distance
library(fdasrvf)
elastic.distance
f_to_srvf
elastic.distance
optimum.reparam
?approx
?trapz
??trapz
inv_exp_map
library(fdasrvf)
inv_exp_map
?f_to_srvf
?optimum.reparam
?gradient.spline
??gradient.spline
optimum.reparam = function (Q1, T1, Q2, T2, lambda = 0, method = "DP", w = 0.01,
f1o = 0, f2o = 0) {
n = length(T1)
if (method == "DP" && all(T1 != T2))
method = "DPo"
Q1 = (Q1/pvecnorm(Q1, 2))
Q2 = (Q2/pvecnorm(Q2, 2))
C1 = srsf_to_f(Q1, T1, f1o)
C2 = srsf_to_f(Q2, T2, f2o)
rotated = FALSE
isclosed = FALSE
skipm = 0
auto = 0
if (method == "DPo") {
G = rep(0, n)
T = rep(0, n)
size = 0
ret = .Call("DPQ2", PACKAGE = "fdasrvf", Q1, T1, Q2,
T2, 1, n, n, T1, T2, n, n, G, T, size, lambda)
G = ret$G[1:ret$size]
Tf = ret$T[1:ret$size]
gam0 = approx(Tf, G, xout = T2)$y
}
else if (method == "DP") {
gam0 = .Call("DPQ", PACKAGE = "fdasrvf", Q2, Q1, 1, n,
lambda, 0, rep(0, n))
}
else if (method == "SIMUL") {
out = simul_align(C1, C2)
u = seq(0, 1, length.out = length(out$g1))
tmin = min(T1)
tmax = max(T1)
timet2 = T1
timet2 = (timet2 - tmin)/(tmax - tmin)
gam0 = simul_gam(u, out$g1, out$g2, timet2, out$s1, out$s2,
timet2)
}
else if (method == "DP2") {
opt = rep(0, n + 1 + 1)
swap = FALSE
fopts = rep(0, 5)
comtime = rep(0, 5)
out = .Call("opt_reparam", PACKAGE = "fdasrvf", C1, C2,
n, 1, 0, TRUE, rotated, isclosed, skipm, auto, opt,
swap, fopts, comtime)
gam0 = out$opt
gam0 = gam0[1:(length(gam0) - 2)]
if (out$swap) {
gam0 = invertGamma(gam0)
}
}
else {
opt = rep(0, n + 1 + 1)
swap = FALSE
fopts = rep(0, 5)
comtime = rep(0, 5)
out = .Call("opt_reparam", PACKAGE = "fdasrvf", C1, C2,
n, 1, w, FALSE, rotated, isclosed, skipm, auto, opt,
swap, fopts, comtime)
if (out$fopts[1] == 1000) {
out = .Call("opt_reparam", PACKAGE = "fdasrvf", C1,
C2, n, 1, 0, TRUE, rotated, isclosed, skipm,
auto, opt, swap, fopts, comtime)
}
gam0 = out$opt
gam0 = gam0[1:(length(gam0) - 2)]
if (out$swap) {
gam0 = invertGamma(gam0)
}
}
gam = (gam0 - gam0[1])/(gam0[length(gam0)] - gam0[1])
return(gam)
}
f_to_srvf = function (f, time) {
binsize <- mean(diff(time))
eps <- .Machine$double.eps
tmp <- gradient.spline(f, binsize)
q <- tmp$g/sqrt(abs(tmp$g) + eps)
return(q)
}
shape_elastic_distance = function (f1, f2, time, lambda = 0) {
q1 <- f_to_srvf(f1, time)
q2 <- f_to_srvf(f2, time)
gam <- optimum.reparam(q1, time, q2, time, lambda)
fw <- approx(time, f2, xout = (time[length(time)] - time[1]) *
gam + time[1])$y
qw <- f_to_srvf(fw, time)
Dy <- sqrt(trapz(time, (q1 - qw)^2))
time1 <- seq(0, 1, length.out = length(time))
binsize <- mean(diff(time1))
psi <- sqrt(gradient(gam, binsize))
v <- inv_exp_map(rep(1, length(gam)), psi)
Dx <- sqrt(trapz(time1, v^2))
return(list(Dy = Dy, Dx = Dx))
}
bone_shapes = bone_list$x
bone_shapes = cbind(bone_shapes, bone_list$y)
bone_1 = bone_shapes[1:100,]
bone_2 = bone_shapes[101:200,]
shape_elastic_distance(bone_1, bone_2)
?elastic.distance
simu_data$f[,1]
simu_data$f[,2]
simu_data$time
shape_elastic_distance(bone_1, bone_2, 1:100)
gradient.spline()
readClipboard()
library(help = fdasrvf)
??elastic.distance
?calc_shape_dist
calc_shape_dist
install.packages("usedist")
library(usedist)
dist_make
?dist_make
x <- matrix(sin(1:30), nrow=5)
x
bone_distances = apply(utils::combn(dim(bone_shapes)[3], 2), 2, procdist)
library(shapes)
bone_distances = apply(utils::combn(dim(bone_shapes)[3], 2), 2, procdist)
utils::combn(dim(bone_shapes)[3], 2)
utils::combn(5, 2)
array
?array
bones = array(c(bone_1, bone_2), dim(100, 2, 2))
bones = array(c(bone_1, bone_2), dim = c(100, 2, 2))
bones
bone_3 = bone_shapes[201:300,]
bones = array(c(bone_1, bone_2, bone_3), dim = c(100, 2, 3))
?apply
?utils::combn
?mapply
?combination
?combinations
??combination
library(gtools)
dists = sapply(combinations(3, 2, bones), procdist)
sapply?
?sapply
dists = sapply(x = y = combinations(3, 2, bones), procdist)
combinations(3, 2, bones)
combinations
?combinations
letters[1:3]
combinations(3,2,letters[1:3])
names(bones))
names(bones)
names(bones) = 1:dim(bones)[3]
ames(bones)
names(bones)
dim(bones)[3]
bones
names(bones[,,1:3]) = 1:3
names(bones)
dimnames(bones)
dimnames(bones[,,1:3]) = 1:3
dimnames(bones) = 1:3
combinations(3, 2, bones)
bones
combinations(3, 2, 1:dim(bones)[3])
bones[,,combinations(dim(bones)[3], 2, 1:dim(bones)[3])]
combinations(dim(bones)[3], 2, 1:dim(bones)[3])
apply(bones[,,combinations(dim(bones)[3], 2, 1:dim(bones)[3])], procdist)
bone_distances = apply(bones[,,combinations(dim(bones)[3], 2, 1:dim(bones)[3])], FUN = procdist)
bone_distances = sapply(bones[,,combinations(dim(bones)[3], 2, 1:dim(bones)[3])], FUN = procdist)
bone_distances = sapply(bones[,,combinations(dim(bones)[3], 2, 1:dim(bones)[3])[,1]], FUN = procdist, y = bones[,,combinations(dim(bones)[3], 2, 1:dim(bones)[3])[,2]])
bone_distances = sapply(bones[,,combinations(dim(bones)[3], 2, 1:dim(bones)[3])[1,]], FUN = procdist, y = bones[,,combinations(dim(bones)[3], 2, 1:dim(bones)[3])[2,]])
